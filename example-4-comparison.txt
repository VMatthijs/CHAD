-- Reverse derivative van example 4 in het paper, omgezet naar haskell-notatie:
\w' ->
  let f   = \x2i -> (x1 * x2i, \y' -> x1 * y')
      ys  = map (\x2i -> fst (f x2i)) x2
      w   = sum ys
      ys' = replicate w'
      f'  = zip x2 ys'
      x1' = sum (map (\x2iy' -> snd x2iy' * fst x2iy') f')  -- was: (Î»(x2i,y'). y' * x2i)
      x2' = zipWith (\x2i -> snd (f x2i)) x2 y'
  in (x1', x2')


-- Reverse derivative van example 4 in de implementatie: zonder let-lambda-splitting
-- Origineel heeft type eps, x1:R, x2:R^n |- w:R.
-- Dus D_2[Gamma] = (((), dR), dR^n).
-- Merk op dat ys en w wegvereenvoudigd zijn, omdat die niet nodig zijn.
let f = \x2i -> (x1 * x2i, \y' -> (((zero, x2i * y'), zero), x1 * y'))
 in \w' ->
      let ys' = vreplicate w'
       in plus
            (zero, vzipWith (\x2i -> \y' -> snd (snd (f x2i) y')) x2 ys')  -- dit is ((0, 0), x2')
            (sum (map (\x2iy' -> fst (snd (f (fst x2iy')) (snd x2iy')))    -- dit is ((0, x1'), 0)
                      (zip (toList x2) (toList ys'))))                     -- dit is f'


-- Reverse derivative van example 4 in de implementatie: met let-lambda-splitting
\w' ->
  let ys' = vreplicate w'
   in plus
        (zero, vzipWith (\_ -> \y' -> x1 * y') x2 ys')               -- dit is ((0, 0), x2')
        (sum (map (\x2iy' -> ((zero, fst x2iy' * snd x2iy'), zero))  -- dit is ((0, x1'), 0)
                  (zip (toList x2) (toList ys'))))                   -- dit is f'
